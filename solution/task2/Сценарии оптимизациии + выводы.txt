3.2 
Можно создать дополнительную таблицу PaymentBalanceUpdate, в которую будем сохранять информацию о платежах, требующих обновления балансов. Требуется модифицировать триггер T_Payment_AI, чтобы он вставлял записи в эту таблицу вместо непосредственного обновления балансов это "уберет" обновление балансов в целевой транзакции (создание/обновление платежей), что точно увеличит производительность (примерно на 40%, как показали измерения в 2.1)

Также можно создать "фоновый" процесс (есть специальные инструменты, например SQL Server Agent Job), которые будут периодически обрабатывать записи из таблицы PaymentBalanceUpdate и делать фактическое обновление балансов в нужных таблицах (т.е. реализовывать функционал, который ранее был в триггере T_Payment_AI)

3.3 
Такой подход позволит максимизировать скорость целевых изменений (создание/изменение платежей), так как обновление балансов будет происходить в фоновом режиме. При этом данные о платежах и балансах будут оставаться согласованными в конечном итоге. Но есть недостатки. Например, в этом случае есть проблемы с "согласованностью в реальном времени". Если в рамках транзакции реализовывается обновление балансов, то есть гарантия, что балансы всегда актуальны. В случае предложенного сценария (фоновое обновление) балансы будут какое-то время неактуальны, либо отображаться с сильной задержкой (требуемой на вычисление актуальных балансов)